# AUTOGENERATED! DO NOT EDIT! File to edit: src/att_stats.ipynb (unless otherwise specified).

__all__ = ['AttStats']

# Cell
from typing import List,Dict
import pandas as pd
import numpy as np
import warnings


from .value import Value
from .attribute import Attribute
# from pyuid3.data import Data   # may cause problems

# Cell
class AttStats:
    def __init__(self, statistics: Dict[str,Value], avg_confidence: float, total_samples: int,  att_type: int):
        self.statistics = statistics
        self.avg_confidence = avg_confidence
        self.att_type = att_type
        self.total_samples = total_samples

    @staticmethod
    def calculate_statistics(att: Attribute, data: 'Data') -> 'AttStats':    # TODO: rename to get_stats
        conf_sum = {}
        avg_conf = 0

        if not data.get_instances():
            return AttStats(conf_sum, avg_conf, 0, att.get_type())

        instances = data.get_instances()
        att_name=att.get_name()
        for instance in instances:
            r = instance.get_reading_for_attribute(att_name)
            values = r.get_values()
            for v in values:
                if v.get_name() in conf_sum.keys():
                    old = conf_sum[v.get_name()]
                    conf_sum[v.get_name()] = Value(v.get_name(), old.get_confidence() + v.get_confidence())
                else:
                    conf_sum[v.get_name()] = v#Value(v.get_name(), old.get_confidence() + v.get_confidence())
            
            avg_conf += r.get_most_probable().get_confidence()

        size = len(data)
        avg_conf /= size
        stats = {}
        for stat_v in conf_sum.values():
            #Walkaround to deal with numerical values that can have decimal places, e.g.to make sure  3 == 3.0
            if att.get_type() == Attribute.TYPE_NUMERICAL:
                stats[str(float(stat_v.get_name()))]=(Value(stat_v.get_name(), stat_v.get_confidence()/size))
            else:
                stats[stat_v.get_name()]=(Value(stat_v.get_name(), stat_v.get_confidence()/size))
        return AttStats(stats, avg_conf, total_samples=size, att_type=att.get_type())




    def get_statistics(self) -> List[Value]: 
        return list(self.statistics.values())

    def get_avg_confidence(self) -> float:
        return self.avg_confidence

    def get_stat_for_value(self, value_name: str) -> float:
        #Walkaround in case of numerical values having decimal places, e.g.to make sure  3 == 3.0
        if self.att_type == Attribute.TYPE_NUMERICAL:
            warnings.warn("Warning: calculating confidence for contibues value. Consider using get_total_stat_for_lt_value or get_total_stat_for_gte_value")
            value_name = str(float(value_name))
        if value_name in self.statistics.keys():
            return self.statistics[value_name].get_confidence()
        else:
            return 0
        
    def get_stat_for_lt_value(self, value_name: str) -> float:        
        return np.sum([c.get_confidence() for v,c in self.statistics.items() if float(value_name) > float(v)])/self.total_samples
    
    def get_stat_for_gte_value(self, value_name: str) -> float:        
        return np.sum([c.get_confidence() for v,c in self.statistics.items() if float(value_name) <= float(v)])/self.total_samples
        

    def get_most_probable(self) -> Value:
        statistics = list(self.statistics.values())
        confidence = [value.get_confidence() for value in statistics]
        highest_conf = max(confidence)
        index = confidence.index(highest_conf)
        return statistics[index]

    def __str__(self) -> str:
        result = '{'
        for value in self.statistics.values():
            result += str(value) + ','
        result = result[:-1]  # delete the last coma ','
        result += '}'
        return result
    
    def copy(self):
        return type(self)(statistics=self.statistics.copy(), avg_confidence=self.avg_confidence ,att_type=self.att_type , total_samples=self.total_samples )
